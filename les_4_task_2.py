# -*- coding: utf-8 -*-
"""
Написать два алгоритма нахождения i-го по счёту простого числа. Функция
нахождения простого числа должна принимать на вход натуральное и возвращать
соответствующее простое число. Проанализировать скорость и сложность
алгоритмов.
Первый — с помощью алгоритма «Решето Эратосфена».
Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
Второй — без использования «Решета Эратосфена».
Примечание. Вспомните классический способ проверки числа на простоту.
"""

import math


def pi_inf(x):
    """Функция распределения простых чисел (нижняя граница) """
    pi_x = {10**1: 4,
            10**2: 25,
            10**3: 168,
            10**4: 1229,
            10**5: 9592,
            10**6: 78498,
            10**7: 664579,
            10**8: 5761455,
            10**9: 50847534
            }
    for k in range(10):
        n = 10**k
        if n > x:
            return pi_x[n // 10]


def sieve(k: int) -> int:
    """Нахождение k-го по счёту простого числа с помощью решета Эратосфена"""
    assert k > 0
    n = int((k+1)*math.log(k+1)*1.5)  # грубая оценка верхней границы поиска
    k -= 1
    if k < 2:
        return 2 if k == 0 else 3
    assert k < (n / (math.log(n)-1))

    nums = [i * (i & 1) for i in range(n)]  # список для решета (цикл A)
                                            # (сразу обнулить все чётные числа)
    nums[1] = 0  # 1 - не простое число
    nums[2] = 2  # 2 - простое число
    for i in range(3, int(n**(1/2))+1, 2):  # (цикл B)
        if nums[i] != 0:
            for j in range(i ** 2, n, i):  # (цикл C)
                nums[j] = 0  # это не простое число

    m = -1+2
    for item in nums[5::2]:  # в цикле по нечётным числам (цикл D)
        if item != 0:  # проверяем очередное число на простоту
            m += 1
            if m == k:
                break
    return item


def isprime(n: int) -> bool:
    """Проверка, является ли число n простым"""
    if n <= 3:
        return n > 1  # 2 и 3 - простые числа
    if not (n % 2) or not (n % 3):
        return False  # все числа, кратные 2 или 3 - не простые
    for i in range(5, int(n**0.5)+1, 6):  # (цикл E)
        if not (n % i) or not (n % (i + 2)):
            # числа i+1, i+3, i+4, i+5 гарантировано делятся либо на 2 либо на 3
            return False  # то это не простое число
    return True  # у n нет нетривиальных делителей - это простое число


def prime(k: int) -> int:
    """Нахождение k-го по счёту простого числа без помощи решета Эратосфена"""
    assert k > 0
    n = int((k+1)*math.log(k+1)*1.5)  # грубая оценка верхней границы поиска
    k -= 1
    if k < 2:
        return 2 if k == 0 else 3
    assert k < (n / (math.log(n)-1))

    m = -1+2
    for i in range(5, n, 2):  # в цикле по нечётным числам (цикл F)
        if isprime(i):  # проверяем очередное число на простоту
            m += 1
            if m == k:
                break
    return i


def test_task(func):
    """Проверка: сравнение с эталонными значениями"""
    etalons = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,
               61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,
               131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
               197, 199)
    for i, item in enumerate(etalons):
        i += 1
        print(f"[{func.__name__}] {i}: {item} = {func(i)}")
        assert item == func(i)


def print_primes(n):
    """Распечатать список простых чисел не превосходящих n"""
    k = 0
    for i in range(n):
        if isprime(i):
            k += 1
            print("%d: %d" % (k, i))


if __name__ == "__main__":
    test_task(sieve)
    test_task(prime)
    # print_primes(10**6)

###############################################################################
# python3 -m timeit -n 100 -s "from les_4_task_2 import <функция>" "<функция>(<N>)"
# ------------------------------------
# |    N   |    sieve   |    prime   |
# ------------------------------------
# |    100 | ~80   usec | ~127  usec |
# |   1000 | ~1.3  msec | ~2.38 msec |
# |  10000 | ~19.5 msec | ~52.5 msec |
# | 100000 | ~336  msec | ~1.68  sec |
# ------------------------------------
###############################################################################

    import cProfile
    N = 100
    X = 10000
    cProfile.run("[sieve(%d) for i in range(%d)]" % (X, N))
#         404 function calls in 1.882 seconds
#      100    0.957    0.010    1.846    0.018 les_4_task_2.py:17(sieve)
    cProfile.run("[prime(%d) for i in range(%d)]" % (X, N))
#         5236604 function calls in 6.165 seconds
#  5236300    5.408    0.000    5.408    0.000 les_4_task_2.py:44(isprime)
#      100    0.757    0.008    6.165    0.062 les_4_task_2.py:57(prime)

###############################################################################

# Сложность алгоритма sieve: ~ O(N*log(log(N))) (сложность решета Эратосфена)

# Сложность алгоритма prime: ~ O(N**(3/2))
# (цикл E):   ~ (N**(1/2))/6 итераций
# (цикл F):   ~ N/2 итераций
# итого: (цикл E)*(цикл F) = (N**(1/2))/6 * N/2 = (N**(3/2))/12 ~ N**(3/2)

# ВЫВОД:
# Функция sieve() за счёт использования решета Эратосфена с каждым проходом
# исключает из рассмотрения всё больше кандидатов в простые числа.
# Функция prime() просто перебирает числа друг за другом и ведёт подсчёт
# встретившимся простым числам.
# Сложность sieve() меньше, чем prime() и sieve() демонстрирует более высокую
# скорость выполнения.
# Однако для работы функции sieve() необходимо выделить память для хранения
# решета, тогда как prime обходится лишь несколькими переменными.
