# -*- coding: utf-8 -*-
"""
Проанализировать скорость и сложность одного любого алгоритма из разработанных
в рамках домашнего задания первых трёх уроков.
Примечание. Идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать,
b. написать 3 варианта кода (один у вас уже есть),
c. проанализировать 3 варианта и выбрать оптимальный,
d. результаты анализа вставить в виде комментариев в файл с кодом
   (не забудьте указать, для каких N вы проводили замеры),
e. написать общий вывод: какой из трёх вариантов лучше и почему.
"""


def reverse_1(number):
    """Инвертировать порядок цифр натурального числа (числовая версия)"""
    result = 0
    while (number > 0):
        digit = number % 10
        result *= 10
        result += digit
        number //= 10
    return result


def reverse_2(number):
    """Инвертировать порядок цифр натурального числа (рекурсивная версия)"""
    def invert(number):
        if (len(number) == 1):
            return number
        else:
            return invert(number[1:]) + number[:1]
    return int(invert(str(number)))


def reverse_3(number):
    """Инвертировать порядок цифр натурального числа (версия со срезами)"""
    return int(str(number)[::-1])


def test_task(n):
    """Проверка: сравнение значений функций reverse() между собой"""
    a = reverse_1(n)
    b = reverse_2(n)
    c = reverse_3(n)
    print("%d : %d = %d = %d" % (n, a, b, c))
    assert a == b == c


if __name__ == "__main__":
    test_task(92233720368547758070)

###############################################################################
# python3 -m timeit -n 100000 -s "from les_4_task_1 import <функция>" "<функция>(<N>)"
# ------------------------------------------------
# |    N   | reverse_1  | reverse_2  | reverse_3 |
# ------------------------------------------------
# | 2**16  | ~630  nsec | ~1.50 usec | ~341 nsec |
# | 2**32  | ~1.29 usec | ~2.67 usec | ~362 nsec |
# | 2**64  | ~3.07 usec | ~5.15 usec | ~408 nsec |
# | 2**128 | ~6.96 usec | ~10.4 usec | ~822 nsec |
# ------------------------------------------------
###############################################################################

    import cProfile
    N = 100000
    X = 92233720368547758070
    cProfile.run("[reverse_1(%d) for i in range(%d)]" % (X, N))
#         100004 function calls in 0.335 seconds
#   100000    0.318    0.000    0.318    0.000 les_4_task_1.py:15(reverse_1)
    cProfile.run("[reverse_2(%d) for i in range(%d)]" % (X, N))
#         4100004 function calls (2200004 primitive calls) in 1.263 seconds
#   100000    0.097    0.000    1.221    0.000 les_4_task_1.py:26(reverse_2)
# 2000000/100000    1.017    0.000    1.124    0.000 les_4_task_1.py:28(invert)
    cProfile.run("[reverse_3(%d) for i in range(%d)]" % (X, N))
#         100004 function calls in 0.062 seconds
#   100000    0.045    0.000    0.045    0.000 les_4_task_1.py:36(reverse_3)

###############################################################################

# Сложность алгоритмов reverse_1, reverse_2, reverse_3: ~ O(N)
# (где N - количество цифр в десятичном представлении числа)

# ВЫВОД:
# Среди трёх функций инвертирования порядка цифр натурального числа лучшие
# результаты продемонстрировала reverse_3().
#
# reverse_1() для вычисления результата использует целочисленную арифметику. Но
# поскольку в Python3 целые числа (int) представлены в формате неограниченного
# размера (bignum), то и арифметические операции над ними далеко не оптимальны
# по быстродействию.
#
# reverse_2() для работы использует рекурсию (что само по себе может привести к
# переполнению стека) и, кроме того, в качестве результата своей работы каждый
# раз возвращает новую строку.
#
# reverse_3() использует механизм срезов Python3, за счёт чего у данной функции
# нет лишних вычислений и лишних пересылок данных, поэтому она и показывает
# лучший результат по скорости.
